<?php

require_once __DIR__ . '/vendor/autoload.php';
use PhpAmqpLib\Connection\AMQPConnection;

$connection = new AMQPConnection('192.168.10.102', 5672, 'guest', 'guest');
$channel = $connection->channel();

/*
	Устойчивость сообщений
	Мы разобрались, как не потерять задачи, если подписчик неожиданно прекратил работу. 
	Но задачи будут утеряны, если прекратит работу сервер RabbitMQ.
	По умолчанию при остановке или падении сервера RabbitMQ все очереди и сообщения теряются, 
	но это поведение можно изменить. Для того чтобы сообщения оставались в очереди после перезапуска сервера, 
	еобходимо сделать как очереди, так и сообщения устойчивыми. 
	Сначала убедимся, что не будет потеряна очередь. Для этого необходимо объявить ее, 
	как устойчивую (durable):
											durable
*/

$channel->queue_declare('task_queue', false, true, false, false);

echo ' [*] Waiting for messages. To exit press CTRL+C', "\n";

$callback = function($msg){
  echo " [x] Received ", $msg->body, "\n";
  sleep(substr_count($msg->body, '.'));
  echo " [x] Done", "\n";
/*
  Иногда разработчики забывают добавить в код basic_ack. Последствия этой небольшой ошибки могут 
  быть существенными. Сообщение будет заново передано только тогда, когда программа-обработчик будет 
  остановлена, но RabbitMQ будет потреблять все больше и больше памяти, т.к. не будет удалять 
  неподтвержденные сообщения.
  Для отладки такого рода ошибок Вы можете использовать rabbitmqctl для вывода на экран поля 
  messages_unacknowledged (неподтвержденные сообщения):
*/
  $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);
};

/*
Равномерное распределение сообщений
=================================================================================================
Проблема: При работе двух подписчиков, если все нечетные сообщения содержат сложные задачи 
[требуют много времени на выполнение], а четные ‒ простые, то первый обработчик будет постоянно занят, 
а второй большую часть времени будет свободен. 
Но RabbitMQ об этом ничего не знает и все-равно будет передавать сообщения подписчикам по очереди.
Так происходит, потому что RabbitMQ распределяет сообщения в тот момент, когда они попадают в очередь, 
и не учитывает количество неподтвержденных сообщений у подписчиков. 
RabbitMQ просто отправляет каждое n-ое сообщение n-ому подписчику.
=================================================================================================


Для того чтобы изменить такое поведение, мы можем использовать метод basic_qos с опцией prefetch_count=1. 
Это заставит RabbitMQ не отдавать подписчику единовременно более одного сообщения. 
Другими словами, подписчик не получит новое сообщение, до тех пор пока не обработает 
и не подтвердит предыдущее. RabbitMQ передаст сообщение первому освободившемуся подписчику.

*/

$channel->basic_qos(null, 1, null);

/*
	Далее, нам нужно обозначить, что callback функция будет получать сообщения из очереди 
	с именем «task_queue»:
	  
	  Чтобы мы могли быть уверенны в отсутствии потерянных сообщений, 
	  RabbitMQ поддерживает подтверждение сообщений. 
	  Подтверждение (ack) отправляется подписчиком для информирования RabbitMQ о том, 
	  что полученное сообщение было обработано и RabbitMQ может его удалить.

								           no_ack
*/
$channel->basic_consume('task_queue', '', false, false, false, false, $callback);

while(count($channel->callbacks)) {
    $channel->wait();
}

$channel->close();
$connection->close();

?>