<?php

require_once __DIR__ . '/vendor/autoload.php';
use PhpAmqpLib\Connection\AMQPConnection;

$connection = new AMQPConnection('192.168.10.102', 5672, 'guest', 'guest');
$channel = $connection->channel();

/*
	Устойчивость сообщений
	Чтобы не потерять задачи, если подписчик неожиданно прекратил работу, нужно включить  подтверждение сообщений (no_ack= false)
	по умолчанию он включен (basic_consume - третий параметр).
	
	Подтверждение (ack) отправляется подписчиком для информирования RabbitMQ о том, 
	что полученное сообщение было обработано и RabbitMQ может его удалить.
	
	Так же задачи будут утеряны, если прекратит работу сервер RabbitMQ.
	По умолчанию при остановке или падении сервера RabbitMQ все очереди и сообщения теряются.
	
	Для того чтобы сообщения оставались в очереди после перезапуска сервера нужно сделать:
	1) Очереди - устойчивые (durable)
	2) Сообщения - устойчивые ('delivery_mode' => 2) - (пример в new_task.php)
	
	Объявляем очередь (durable):
											durable
*/

$channel->queue_declare('task_queue', false, true, false, false);

echo ' [*] Waiting for messages. To exit press CTRL+C', "\n";

$callback = function($msg){
  echo " [x] Received ", $msg->body, "\n";
  sleep(substr_count($msg->body, '.'));
  echo " [x] Done", "\n";
/*
    
  Отправляем ack.
  Ошибка: Нельзя забывать добавлять в код basic_ack.
  =================================================================================================
  Если забыть добавить в код basic_ack - то сообщение будет заново передано только тогда, когда программа-обработчик будет 
  остановлена.
  RabbitMQ будет потреблять все больше и больше памяти, т.к. не будет удалять 
  неподтвержденные сообщения.
  
  Для отладки такого рода ошибок Вы можете использовать rabbitmqctl для вывода на экран поля 
  messages_unacknowledged (неподтвержденные сообщения):
	=================================================================================================
*/
  $msg->delivery_info['channel']->basic_ack($msg->delivery_info['delivery_tag']);
};

/*
Равномерное распределение сообщений
=================================================================================================
Проблема: Задачи могут быть разные по сложности, поэтому некоторые обработчики могут простаивать без дела.
RabbitMQ распределяет сообщения в тот момент, когда они попадают в очередь, 
и не учитывает количество неподтвержденных сообщений у подписчиков. 
RabbitMQ просто отправляет каждое n-ое сообщение n-ому подписчику.
=================================================================================================


Метод basic_qos с опцией prefetch_count=1 - изменяет данное поведение.

Это заставит RabbitMQ не отдавать подписчику единовременно более одного сообщения. 
Другими словами, подписчик не получит новое сообщение, до тех пор пока не обработает 
и не подтвердит предыдущее. 

RabbitMQ передаст сообщение первому освободившемуся подписчику.

*/

$channel->basic_qos(null, 1, null);

/*
	Далее, нам нужно обозначить, что callback функция будет получать сообщения из очереди 
	с именем «task_queue»:
										  no_ack
*/
$channel->basic_consume('task_queue', '', false, false, false, false, $callback);

while(count($channel->callbacks)) {
    $channel->wait();
}

$channel->close();
$connection->close();

?>